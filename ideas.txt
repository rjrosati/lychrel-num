I might have to roll something custom to get great performance out of this thing...

See https://gmplib.org/list-archives/gmp-discuss/2008-July/003343.html -- GMP is radix 2^k,
  which is awesome for applications that don't require twiddling base-10 digits.
Unfortunately converting back and forth from base-10 to base 2^32 or whatever is slow.
Base-10 would have an insane amount of carries. Maybe I can use a power of 10 radix, should mean easy access to my digits right?

Another likely bottleneck: using strings to reverse the digits.
Surely I can just add them in reverse order? (assuming the radix problem was cool...)
I don't know much x86 assembler, hopefully I won't need it.

Parallelization: I got OpenMP working, this problem turns out to be embarrassingly parallel.
Maybe I should distribute this as well? MPI? I don't know the architecture of the supercomputer here.


Update: I rolled some bigint code, seems to get about 1.3x the performance of GMP. Mostly from avoiding strings I would guess.
Which is okay, maybe I can get it faster. It's in base-10 radix, so the number of carries can be greatly reduced by upping that.
I didn't code in any operations other than self-reverse-addition and addition to an assumedly-small int with fewer digits
    than the bigint.


Apr 25 2016
MPI working
see codes here: http://www.p196.org/ben-mirror/ben-mirror.html , see if there are any good ideas?
need to optimize before putting on supercomputer
I don't know enough assembler to understand half the codes on that site. Here's hoping -O3 is as good as they are.

Apr 28 2016
I came across a blog post claiming all 20-digit numbers have been checked and failed to yield a more delayed palindrome than the old 261-iteration-er. (http://datagenetics.com/blog/october12015/index.html)
With this in mind, I'll try to search in the 21 digit range. Although, as this blog has made me aware, these numbers are becoming more and more likely to be Lychrel as they get bigger.
